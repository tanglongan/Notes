### 一、动态规划

本文描述动态规划的套路，形成一套解决这类问题的思维框架。

`动态规划的一般形式就是求最值。` 动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上比较多。比如求最长递增子序列、最小编辑距离等等。既然是求最值，核心问题是什么呢？`动态规划的核心问题就是穷举。` 因为要求最值，肯定要把司所有可能的答案穷举出来，然后找最优解。

动态规划问题其实并不难。

首先，动态规划的穷举有点特别，因为这类问题`存在「重叠子问题」`，如果暴力穷举的话，可能效率非常低下，所以应该使用**[备忘录]或者[DPTable]**才能正确的穷举。

其次，动态规划问题一定存在`最优子结构`，才能通过子问题找到原问题的最优解。

另外，虽然动态规划的核心问题是穷举最值，你是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，还有列出`正确的状态转移方程`才能真确的穷举。

以上提到的就是动态规划问题的三要素：

* 重叠子问题
* 最优子结构
* 状态转移方程

一般来说，**状态转移方程**是最困难的，也是解决动态规划问题的最困难的点。这里提供了一个找到状态转移方程的思维框架来帮助思考状态状态转移方程：

**明确状态**-->**定义dp数组/函数的含义** -->**明确选择** --> **明确base**。

下面通过斐波拉契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是要明白什么是重叠子问题（斐波拉契数列严格来说不是动态规划问题），后者主要是明白如何找出状态转移方程。

### 二、斐波那契数列

#### 1、暴力递归

斐波那契梳理的数学问题形式就是递归的，写成代码就是这样

```java
int fib(int N){
  if(N==1 || N==2) {
    return 1;
  } else {
    return fib(N-1) + fib(N-2);
  }
}
```

这个解法的代码简单易懂，但是十分低效，抵消在哪里？假设n=20，请画出递归树。

PS：凡是需要递归的问题，最好画出递归树，这对你分析算法的复杂度，寻找算法抵消的原因有巨大帮助。

<img src="/Users/tanglongan/Notes/算法/.images//image-20201019202040918.png" alt="image-20201019202040918" style="zoom:50%;" />

这个递归树怎么理解？就是说想要计算原问题`f(20)`，就需要先计算子问题`f(19)`和`f(18)`，然后要计算`f(19)`，就要先计算`f(18)`和`f(17)`，以此类推。最后遇到`f(1)`和`f(2)`的时候，结果已知，就能直接返回结果，递归树就不再向下生长了。

**递归算的时间复杂度怎么样？子问题个数乘以一个子问题需要的时间。**

子问题的个数，即递归树中节点的总数。显然二叉树中节点中枢为指数级别。所以子问题的个数为**O(2^n)**。解决一个子问题的时间，在本算法中，没有循环，只有f(n - 1) + f(n - 2) 一个加法操作，时间为**O(1)**。所以，这个算法的时间复杂度为**O(2^n)**，指数级别，爆炸。

观察递归树，很明显发现了算法低效的原因：存在大量的重复计算，比如`f(18)` 被计算了两次，而且你可以看到，以 `f(18)` 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 `f(18)` 这一个节点被重复计算，所以这个算法及其低效。这就是动态规划问题的第一个性质：**重叠子问题**。下面就解决这个问题。

#### 2、带备忘录的递归解法

明确了问题，其实就已经解决了一半。既然耗时的原因是重复计算，那么我们可以构造一个`备忘录`，每次算出子问题的答案后别急着返回，先记在`备忘录`中再返回；每次遇到一个子问题先去`备忘录`中查一查，如果发现之前已经解决过这个问题，直接把答案拿出来，不用再耗时去计算了。**一般使用数组充当这个备忘录，当然也可以用哈希表，思维是一样的。**

```java
public int fib(int n) {
  if (n < 1) return 0;
  List<Integer> memo = new ArrayList<Integer>();
  //初始化最简情况
  return helper(memo, n);
}

public int helper(List<Integer> memo, int n) {
  if (n == 1 | n == 2) return 1;
  if (memo.get(n) != 0) return memo.get(n);//已经计算过，直接返回
  memo.set(n, helper(memo, n - 1) + helper(memo, n - 2));
  return memo.get(n);
}
```

现在画出递归树，就知道`备忘录`到底做了什么。

<img src="/Users/tanglongan/Notes/算法/.images//image-20201020094759316.png" alt="image-20201020094759316" style="zoom:50%;" />

实际上带了备忘录的递归算法，把一颗存在巨量冗余的递归树通过剪枝，改造成一副不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。

<img src="/Users/tanglongan/Notes/算法/.images//image-20201020095149023.png" alt="image-20201020095149023" style="zoom:50%;" />

递归算法的复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是`f(1)`, `f(2)`, `f(3)` ... `f(20)`。数量和输入规模n=20成正比，所以子问题个数为`O(n)`。解决一个子问题的时间，同上，没有什么循环，时间为`O(1)`。所以本算法的时间复杂度为`O(n)`，比起暴力算法，是降维打击。至此，带备忘录的递归解法的效率已经和迭代的动态规划一样了，只不过这种解法叫做「自顶向下」，而动态规划叫做「自底向上」。

什么是自顶向下？从上面的递归树图中，我们是从上向下延伸，都是从一个规模较大的原问题比如说`f(20)`，向下主键分解规模，直到`f(1)`和`f(2)`触底，然后逐层返回答案，这就叫自顶向下。

什么是自底向上？反过来，我们直接从最底下，最简单，问题规模最小的`f(1)`和`f(2)`，开始向上推，直到推到我们想要的答案`f(20)`，这就是动态规划的思路，这也是为什么动态规划一般都是脱离了递归，而是由循环循环完成计算的。

#### 3、DP数组的迭代解法

有了上一步备忘录的启发，我们可以把这个备忘录独立出来称为一张表，就叫做DPTable吧，在这张表上完成自底向上的推算会更好。

```java
public int fib(int n) {
  Integer[] dp = new Integer[n + 1];
  dp[1] = dp[2] = 1;
  for (int i = 3; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
}
```

<img src="/Users/tanglongan/Notes/算法/.images//image-20201020105612345.png" alt="image-20201020105612345" style="zoom:50%;" />

画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：

![image-20201020111103626](/Users/tanglongan/Notes/算法/.images//image-20201020111103626.png)

为什么叫状态转移方程？为了听起来高端。把f(n)想做一个状态n，这个状态n是有状态n-1和状态n-2相加转移而来，这就叫状态转移方程。你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。

**千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程**，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：

```java
int fib(int n) {
    if (n == 2 || n == 1) 
        return 1;
    int prev = 1, curr = 1;
    for (int i = 3; i <= n; i++) {
        int sum = prev + curr;
        prev = curr;
        curr = sum;
    }
    return curr;
}
```

有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在演示算法设计螺旋上升的过程。看第二个例子，凑零钱问题。

### 三、凑零钱问题

题目：给你K种面值的硬币，面试分别是`c1、c2、c3...ck`，每种硬币的数量无限，再给一个总金额`amount`，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回`-1`。算法的函数签名如下：

```java
int coinChange(int[] coins, int amount); //coins是可选硬币，amount是目标金额
```

比如说`k=3`，面值分别是1,2,5，总金额amount=11。那么最少需要3枚硬币凑出，即11 = 5+5+1。你认为计算机应该如何解决这个问题？显然，就是把所有可能的凑硬币的方法都穷举出来，然后找出最少需要多少枚硬币。

#### 1、暴力破解

首先，这个问题是动态规划问题，因为它具有**最优子结构**的。要符合最优子结构，子问题间必须互相独立。什么叫互相独立？用一个直观的例子来讲解。比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高....为了每门课考到最高，要把每门课相应的选择题分数拿到最高，填空题分数拿到最高...当然，最终就是每门课都是满分，这就是最高的总成绩。

得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是相互独立的，互不干扰的。但是如果增加一个条件：你的语文成绩和数学成绩互相制约，此消彼长的。这样的话，显然你能考到的最高总成绩就达不到总分了，按照刚才那个思路就会得到错误的结果。因为子问题不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。

回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求`amount=11`时的最少硬币数（原问题），如果你知道amount=10的最少硬币数（子问题），你只需要把子问题的答案加一就是原问题的答案，因为硬币的数量是没有限制的，子问题之间没有相互制约，是互相独立的。那么既然知道了这是个动态规划的问题，就要思考**如何列出正确的状态转移方程？**

**先确定状态**，即原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额`amount`。

**确定DP函数的定义**，当前目标金额n，至少需要`dp(n)`个硬币凑出该金额。

**确定选择并择优**，也就是对每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当前目标金额是多少，选择就是从面额列表coins中选择一个硬币，然后目标金额就会减少。

```python
# 伪码框架
def coinChange(coins: List[int], amount: int):
    # 定义：要凑出金额 n，至少要 dp(n) 个硬币
    def dp(n):
        # 做选择，选择需要硬币最少的那个结果
        for coin in coins:
            res = min(res, 1 + dp(n - coin))
        return res
    # 我们要求的问题是 dp(amount)
    return dp(amount)
```

最后明确base case，显然目标金额是0，所需硬币数量是0；当目标金额小于0时，无解，返回-1；

```python
def coinChange(coins: List[int], amount: int):

    def dp(n):
        # base case
        if n == 0: return 0
        if n < 0: return -1
        # 求最小值，所以初始化为正无穷
        res = float('INF')
        for coin in coins:
            subproblem = dp(n - coin)
            # 子问题无解，跳过
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)
        return res if res != float('INF') else -1
    return dp(amount)
```

