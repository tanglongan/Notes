## 1、MySQL事务

> - 事务的隔离级别有哪些？MySQL默认的隔离级别是什么？
> - 什么是脏读、不可重复读、幻读？
> - MySQL事务的四大特性以及实现原理？
> - MVCC是什么？它的实现原理

## 2、事务的基本特性

#### 2.1、事务四大特性

事务是一组数据库操作组成的逻辑处理单元。具有4个特性，通常称为事务的ACID属性。

- 原子性（Atomicity）：整个事务中所有操作，要么全部执行成功，要么全部失败，不能停止中间某个状态。
- 一致性（Consistency）：事务开始之前和结束之后，数据库的完整性约束没有被破坏。
- 隔离性（Isolation）：一个事务内部的操作与使用的数据，对于其他事务是隔离的，并发的各个事务之间不能互相干扰。
- 持久性（Durability）：事务结束执行之后，事务所做的所有操作的变更持久的保存在了数据库中，并不会被回滚。

#### 2.2、并发事务产生的问题

- 更新丢失（Lost update）：事务A和事务B同时更新数据，先提交的事务的更新结果被后提交事务变更结果给覆盖了。

- 脏读（Dirty Read）：事务B读取到了事务A中没有提交的变更操作结果，一旦事务A回滚了，事务B读取到的数据就是脏数据。

- 不可重复读（Non-Repeateable）：事务A中多次读取同一数据，事务B在事务A多次读取过程中对数据做了更新操作，导致事务A多次读取结果不一致。

- 幻读（Phantom Read）：幻读和不可重复读类似。事务A在读取几行数据之后，事务B插入新数据，事务A再次读取数据的时候，发现数据多了。

    > 不可重复读和幻读的区别：
    >
    > - 不可重复读的重点是数据发生了修改，导致数据不一致
    > - 幻读的重点是发生新增/删除数据，导致数据不一致

#### 2.3、并发事务带来问题的解决方法

- 更新丢失：通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。
- 脏读、不可重复读和幻读：本质上都是数据库的一致性问题，必须由数据库提供一定的数据库隔离机制来保证
    - 加锁：在读取数据之前，对数据加锁防止其他事务对数据的修改
    - 数据多版本控制机制MVCC：不用加任何锁，通过一个机制，生成一个数据库请求时间点的一致性数据库快照，并用这个快照提供一定级别（语句级或事务级）的一致性读取。从用户角度看，好像数据库可以看到同一数据的不同版本。

## 3、事务隔离级别

SQL标准的数据库隔离级别有4种，从低到高分别如下：

- 读未提交（Read Uncommited）：最低级别，允许读取其他事务未提交的变更，会导致脏读、不可重复读和幻读。
- 读已提交（Read Commited）：允许读取并发事务已经提交的数据，可以防止脏读，但是会导致不可重复读和幻读。
- 可重复读（Repeatable Read）：对同一数据的多次读取结果都是一致的，除非被事务本身修改。可以防止脏读和不可重复读，但是会出现幻读。
- 串行化（Serializable）：最高隔离级别，完全服从ACID的隔离级别。所以事务都是按顺序执行，可以防止脏读、不可重复读以及幻读的问题。

查看当前数据库的隔离级别

```mysql
show variables like '%isolation%'  #查看数据库支持哪些隔离级别
select @@tx_isolation			   #MySQL8.0之前查看当前数据库隔离级别
select @@transaction_isolation	   #MySQL8.0之后查看当前数据库隔离级别
```

| 隔离级别 | 读数据一致性                               | 脏读 | 不可重复读 | 幻读 |
| -------- | ------------------------------------------ | ---- | ---------- | ---- |
| 读未提交 | 最低级别，只能保证不读取物理上不损坏的数据 | 是   | 是         | 是   |
| 读已提交 | 语句级                                     | 否   | 是         | 是   |
| 可重复读 | 事务级                                     | 否   | 是         | 是   |
| 串行化   | 最高级，事务级                             | 否   | 否         | 否   |

事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。MySQL数据库InnoDB存储引擎的默认隔离级别是可重复读。

## 4、多版本并发控制MVCC

- 可以认为MVCC是行级锁的一个变种，但很多情况下都避免了加锁操作，开销更低。都实现非阻塞的读操作，写操作也只是锁定需要修改的行。

- MVCC的实现是保存数据在某个时间点上的快照实现的。也就是说不管执行多长时间，执行结果都是一致的。
- MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。
- InnoDB的MVCC实现：是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间，而是系统版本号（system version  number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

REPEATABLE READ可重复读隔离级别下，MVCC是如何工作的：

- INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号
- DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识
- UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识
- SELECT：InnoDB会根据以下两个条件检查每行记录，只有符合上述两个条件的才会被查询出来
    - InnoDB只查找版本早于当前事务版本的数据行，这可以确保事务读取的行，是在开始事务之前已存在或事务自身插入或者修改过的
    - 行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除

## 5、事务日志

InnoDB 使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。

事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。

InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。

InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。

事务日志可以帮助提高事务效率：

- 使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。
- 事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。
- 事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。
- 如果数据的修改已记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。

## 6、事务的实现

事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。

事务的实现就是如何实现ACID特性。

事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。

事务日志包括：**重做日志redo log**和**回滚日志undo log**

- **redo log（重做日志**） 实现持久化和原子性

      

- 