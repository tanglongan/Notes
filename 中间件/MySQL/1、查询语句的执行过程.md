### MySQL的基础架构

先来了解一下MySQL的基础架构，看一看MySQL内部的各个零件。

<img src=".images/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom: 25%;" />

大体来说，MySQL可以分为Server层和存储引擎两部分。不同的存储引擎共用一个Server层，也就是连接器到执行器这部分的组件。

- Server层：连接器、解析器、查询缓存、优化器、执行器等。覆盖了MySQL的大部分核心功能，以及包含了内置函数和跨存储引擎的功能。
- 存储引擎层：负责数据的存储和提取。这一层的架构是插件模式的，支持InnoDB、MyISAM、Memory等存储引擎。

### 连接器

使用数据库首先要进行连接，而等待你去连接的组件就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般如下：

```mysql
mysql -h$ip -P$port -u$user -p$password
```

### 查询缓存

连接建立之后，就可以执行select语句了，执行逻辑就来到了第二步：查询缓存。

MySQL拿到一个查询请求之后，先到查询缓存中查看，有没有执行过同样的语句，之前执行过的语句和结果会以Key-Value的形式进行存储，被缓存在内存中。key是查询的语句，value是查询的结果。如果查询的语句能够在缓存中找到就直接返回给客户端，不再执行后续的步骤。

但是大多数情况下，建议不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利，原因分析如下：

查询缓存的失效非常频繁，因为只要对这个表进行过更新，那么这个表涉及到的查询查询都会失效。对于一个更新压力大的数据库，查询缓存的命中率就会非常低。MySQL提供了`query_cache_type`参数设置查询缓存，如果设置为`DEMAND`，这样就会关闭查询缓存的功能。需要注意的是MySQL8.0中直接移除掉了查询缓存的功能。

### 分析器

如果没有命中查询缓存，就会开始真正执行SQL了。首先要对SQL进行语法分析，判断SQL语句是否符合语法要求。

### 优化器

经过了分析器处理之后，MySQL知道了用户想要做什么。在开始执行之前，还要经过优化器处理。优化器是当表中有一些索引信息的时候，决定如何使用这些索引，或者查询有多表关联的时候，如何决定表的连接顺序。

```sql
mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

- 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。

- 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。

这两种方案最终结果是相同的，但是查询效率不同，而优化器就是决定使用哪一种查询方案。优化器阶段处理完成之后，执行方案就基本确定下来了。

### 执行器

MySQL通过分析器知道了要做什么，通过优化器知道了该怎么做，于是就进入到了执行器阶段，开始执行语句。

开始的时候，先判断一下当前用户有没有对表操作的权限，如果没有就会返回没有权限的错误信息，否则继续执行。打开表的时候，就会根据表的存储引擎定义，去调用引擎的接口。

```sql
mysql> select * from T where ID=10;
ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：

1. 调用InnoDB引擎接口取这个表的第一行，判断ID是不是等于10，如果不是就跳过，如果是就将这样数据存储在结果集中
2. 调用引擎的接口读取下一行，重复上一步中相同的判断和处理逻辑，直到表的最后一行。
3. 执行器将上面遍历查询的结果集返回给客户端。

