Pod是Kubernetes的最小管理单元，在Kubernetes中，按照Pod的创建方式可以将其分为两类：

* **自主式Pod**：Kubernetes直接创建出来的Pod，这种Pod删除后就没有了，也不会重建
* **控制器创建的Pod**：Kubernetes通过控制器创建的Pod，这种Pod删除了之后还会自动创建，维持到预期的副本数

Pod控制器是管理Pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器，想要几个什么样的Pod就可以了，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod。

![image-20210524105424478](.images/image-20210524105424478.png)

# ReplicaSet（RS）

ReplicaSet的主要作用是**保证一定数量的Pod正常运行**，它会持续监控这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。同时它还支持对Pod数量的扩容缩容和镜像版本的升降级。

![image-20210524141159791](.images/image-20210524141159791.png)

## 资源清单

```yaml
apiVersion: apps/v1
kind: ReplicaSet              #资源类型
metadata:                     #元数据
  name:                       #元数据，控制器名称
  namespace:                  #元数据，控制器名称空间
  labels:                     #元数据，控制器的标签
    controller: rs
spec:                         #资源规格
  replicas: 3                 #副本数量
  selector:                   #选择器，通过它指定该控制器应该管理哪些Pod
    matchLabels:              #Labels的匹配规则
      app: nginx-pod
    matchExpressions:         #Expression的匹配规则
      - key: app
        operator: In
        values:
          - nginx-pod
  template:                   #Pod模板，如果Pod副本个数不足时，会根据这里的模板创建Pod
    metadata:
      name: nginx-pod
      namespace: dev
      labels:
        app: nginx-replicaset
    spec:
      containers:
        - name: nginx
          image: nginx:1.17.1
          ports:
            - containerPort: 80
```

在这里需要关注的是spec下面的几个配置项：

* **Replicas**：Pod副本数量，其实就是当前RS创建出来之后的Pod数量，默认为1。
* **selector**：选择器，主要作用就是建立Pod控制器和Pod之间的关联关系，采用的是Label Selector机制，在Pod模板上定义label，在控制器上定义控制器，就可以表明当前控制器能管理哪些Pod了。
* **template**：模板，就是当前控制器创建Pod所使用的的模板，其实就是Pod定义。

## RS创建

1. 创建pc-replicaset.yaml，内容如下：

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: pc-replicaset
  namespace: dev
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
        - name: nginx
          image: nginx:1.17.1
```

2. 部署应用

```shell
#创建rs
[root@node01]> kubectl create -f pc-replicaset.yaml
replicaset.apps/pc-replicaset created

#查看rs
[root@node01]> kubectl get rs -n dev -o wide
NAME            DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES         SELECTOR
pc-replicaset   2         2         2       49s   nginx        nginx:1.17.1   app=nginx-pod

#查看当前控制器创建出来的pod列表
#可以看出，Pod控制器名称是在控制器名称后面拼接了-xxxxxx随机码
[root@node01]> kubectl get pod -n dev
NAME                  READY   STATUS    RESTARTS   AGE
pc-replicaset-crrjp   1/1     Running   0          2m7s
pc-replicaset-fcrjz   1/1     Running   0          2m7s
```

## 弹性伸缩

RS能够对部署的Pod数量进行弹性伸缩：

```shell
#修改rs的副本数量（spec.replicas: 4）
[root@node01]> kubectl edit rs pc-replicaset -n dev
replicaset.apps/pc-replicaset edited

[root@node01]> kubectl get pod -n dev
NAME                  READY   STATUS    RESTARTS   AGE
pc-replicaset-crrjp   1/1     Running   0          4m53s
pc-replicaset-fcrjz   1/1     Running   0          4m53s
pc-replicaset-lgptf   1/1     Running   0          30s
pc-replicaset-vrjp8   1/1     Running   0          30s

# 当然也可以直接通过命令修改实现
# 使用scale命令实现扩缩容，后面--replicas=n直接指定目标数量即可
[root@node01]> kubectl scale rs pc-replicaset --replicas=2 -n dev
replicaset.apps/pc-replicaset scaled

#查看Pod列表
[root@node01]# kubectl get pod -n dev -o wide
NAME                  READY   STATUS    RESTARTS   AGE     IP            NODE     NOMINATED NODE   READINESS
pc-replicaset-crrjp   1/1     Running   0          7m29s   10.244.1.23   node02   <none>           <none>
pc-replicaset-fcrjz   1/1     Running   0          7m29s   10.244.2.3    node03   <none>           <none>
```

## 镜像更新

RS能够提供在线的镜像版本更新操作

```shell
#编辑rs的容器镜像 -image: nginx:1.17.2
[root@node01]> kubectl edit rs pc-replicaset -n dev
replicaset.apps/pc-replicaset edited

#查看rs，可以看出镜像版本更新了
[root@node01]> kubectl get rs -n dev -o wide
NAME            DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES         SELECTOR
pc-replicaset   2         2         2       10m   nginx        nginx:1.17.2   app=nginx-pod

# 类似的，也可以通过命令直接完成更新操作
[root@node01]> kubectl set image rs pc-replicaset nginx=nginx:1.17.1 -n dev
replicaset.apps/pc-replicaset image updated

#再次查看，发现镜像版本更新了
[root@node01 pod-ctl]# kubectl get rs -n dev -o wide
NAME            DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES         SELECTOR
pc-replicaset   2         2         2       11m   nginx        nginx:1.17.1   app=nginx-pod
```

## 删除RS

以下是删除RS的操作

```shell
#使用kubectl delete命令删除此rs以及它管理的Pod
#在Kubernetes删除RS之前，会将RS的replicasscaler调整为0，等待所有的Pod被删除之后，再执行RS对象的删除
kubectl delete rs pc-replicaset -n dev

#查看Pod列表
kubectl get pod -n dev - o wide

#如果仅仅希望只删除RS对象并保留Pod，可以使用Kuberctl delete命令时添加 --cascade=false选项（不推荐）
kubectl delete rs pc-replicaset -n dev --cascade=false

#查看Pod列表
kubectl get pod -n dev - o wide

#也可以通过yaml直接删除(推荐)
[root@node01]> kubectl delete -f pc-replicaset.yaml
replicaset.apps "pc-replicaset" deleted
```

# Deployment（Deploy）

为了更好的解决服务编排的问题，Kubernetes在V1.2版本开始，引入了Deployment控制器。值得一提的是，这个控制器并不直接管理Pod，而是通过管理ReplicaSet来间接管理Pod，也就是说，Deployment管理ReplicaSet，ReplicaSet管理Pod，Deployment比ReplicaSet还有一些更强大的功能。

![image-20210524141648193](.images/image-20210524141648193.png)

Deployment的主要功能：

* 支持ReplicaSet的所有功能
* 支持发布的停止、继续
* 支持版本滚动和回滚

## 资源清单

```yaml
apiVersion: apps/v1              #版本号
kind: Deployment                 #资源类型
metadata:                        #元数据
  name:
  namespace:
  labels:
    controller: deploy
spec:                            #规格详情
  replicas: 4                    #副本数量
  revisionHistoryLimit: 3        #保留历史版本个数
  paused: false                  #暂停部署。默认是false
  progressDeadlineSeconds: 600   #部署超时时间（s），默认是600
  strategy:                      #策略
    type: RollingUpdate          #滚动更新策略
    rollingUpdate:               #滚动更新
      maxSurge: 30%              #最大额外可以存在的副本数，可以为百分比，也可以为整数
      maxUnavailable: 30%        #最大不可用状态的Pod的最大值，可以为百分比，也可以为整数
  selector:                      #选择器。通过它指定该控制器管理哪些Pod
    matchLabels:                 #Labels匹配规则
      app: nginx-pod
    matchExpressions:            #Expression匹配规则
      - {key: app, operator: In, values:[nginx-pod]}
  template:                      #模板，当副本数量不足时，会根据模板创建Pod副本
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
        - name:  nginx
          image:  nginx:1.17.1
          ports:
          - containerPort: 80
```

## deploy创建

1. 创建pc-deployment.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pc-deployment
  namespace: dev
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
        - name: nginx
          image: nginx:1.17.1
```

2. 部署应用

```shell
# 创建Deployment
[root@node01]> kubectl create -f pc-deployment.yaml
deployment.apps/pc-deployment created

#查看deploy
# UP-TO-DATE：最新版本的Pod数量、AVAILABLE：可用的Pod数量
[root@node01]> kubectl get deploy pc-deployment -n dev -o wide
NAME            READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES         SELECTOR
pc-deployment   2/2     2            2           3m36s   nginx        nginx:1.17.1   app=nginx-pod

#查看rs
#可以看到rs的名称是在原来Deployment的名字后面添加了一个10个字符的随机串
[root@node01]> kubectl get rs -n dev
NAME                       DESIRED   CURRENT   READY   AGE
pc-deployment-5d9c9b97bb   2         2         2       4m

#查看Pod
[root@node01 pod-ctl]# kubectl get pod -n dev -o wide
NAME                             READY   STATUS    RESTARTS   AGE     IP            NODE     NOMINATED
pc-deployment-5d9c9b97bb-cwzs6   1/1     Running   0          6m54s   10.244.2.4    node03   <none>           
pc-deployment-5d9c9b97bb-hln2g   1/1     Running   0          6m54s   10.244.1.26   node02   <none>           
```

## 弹性伸缩

Deploy通过RS能够对部署的Pod数量进行弹性伸缩

```shell
#变更副本数量为4个
[root@node01]> kubectl scale deploy pc-deployment --replicas=4 -n dev
deployment.apps/pc-deployment scaled

#查看Deploy列表
[root@node01]> kubectl get deploy -n dev
NAME            READY   UP-TO-DATE   AVAILABLE   AGE
pc-deployment   4/4     4            4           15m

#查看Pod列表，发现已经调整为4个Pod副本
[root@node01]> kubectl get pod -n dev
NAME                             READY   STATUS    RESTARTS   AGE
pc-deployment-5d9c9b97bb-44847   1/1     Running   0          8s
pc-deployment-5d9c9b97bb-4hk9t   1/1     Running   0          8s
pc-deployment-5d9c9b97bb-cwzs6   1/1     Running   0          13m
pc-deployment-5d9c9b97bb-hln2g   1/1     Running   0          13m

#编辑deployment的副本数量，修改spec.replicas: 2即可
[root@node01 pod-ctl]# kubectl edit deploy pc-deployment -n dev
deployment.apps/pc-deployment edited

#再次查看deploy列表
[root@node01 pod-ctl]# kubectl get deploy -n dev
NAME            READY   UP-TO-DATE   AVAILABLE   AGE
pc-deployment   2/2     2            2           17m

#查看Pod列表
[root@node01 pod-ctl]# kubectl get pod -n dev
NAME                             READY   STATUS    RESTARTS   AGE
pc-deployment-5d9c9b97bb-cwzs6   1/1     Running   0          17m
pc-deployment-5d9c9b97bb-hln2g   1/1     Running   0          17m
```

## 镜像更新

deployment支持两种更新策略：

* 重建更新和滚动更新
* 可以通过strategy指定策略类型，支持两个属性

```yaml
strategy:           #指定新的Pod替换旧的Pod的策略， 支持两个属性：
  type:             #指定策略类型，支持两种策略
    Recreate:       #在创建出新的Pod之前会先杀掉所有已存在的Pod
    RollingUpdate:  #滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本Pod
  rollingUpdate:    #当type为RollingUpdate时生效，用于为RollingUpdate设置参数，支持两个属性：
    maxUnavailable: #用来指定在升级过程中不可用Pod的最大数量，默认为25%。
    maxSurge:       #用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。
```

### 重建更新

1. 修改pc-deployment.yaml文件，在spec节点下添加更新策略

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pc-deployment
  namespace: dev
spec:
  strategy:
    type: Recreate
  replicas: 2
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
        - name: nginx
          image: nginx:1.17.1
```

2. 使用deploy进行验证

```shell
#变更镜像
[root@node01]> kubectl set image deploy pc-deployment nginx=nginx:1.17.2 -n dev
deployment.apps/pc-deployment image updated

#查看deploy列表
[root@node01]> kubectl get deploy -n dev -o wide
NAME            READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         SELECTOR
pc-deployment   2/2     1            2           28m   nginx        nginx:1.17.2   app=nginx-pod
```

### 滚动更新

1. 修改pc-deployment.yaml文件，注意spec节点下的配置

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pc-deployment
  namespace: dev
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 25
      maxUnavailable: 25
  replicas: 2
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
        - name: nginx
          image: nginx:1.17.1
```

2. 创建Pod进行验证

```shell
#变更镜像
[root@node01]> kubectl set image deploy pc-deployment nginx=nginx:1.17.3 -n dev
deployment.apps/pc-deployment image updated

#观察升级过程
[root@node01]> kubectl get pods -n dev -w
NAME                             READY   STATUS              RESTARTS   AGE
pc-deployment-76fd8c7f84-vxdzn   0/1     ContainerCreating   0          5s
pc-deployment-7c7477c7ff-dv62f   1/1     Running             0          3m52s
pc-deployment-7c7477c7ff-lpspv   1/1     Running             0          3m24s
```

























































































