## 1、不可变类

不可变类（Immutable Class）是指当一个对象被创建出来以后，它的值就不能被修改了。也就是说，一个对象一旦被创建出来，在其整个生命周期内，它的成员变量都不能被修改了。它有点类似于常量，只允许别的程序读，不允许别的程序修改。

### 1.1、创建不可变类的5个准则：

- 类中所有成员变量都被private修饰

- 类中没有写或修改成员变量的方法，只提供构造方法，一次生成，永不改变。比如setXXX方法之类等。

- 确保类中所有方法不会被子类覆盖，可以通过把类定义为final或者把类中的方法定义为final来达到这个目的。

- 如果一个类成员不是不可变量，那么在成员初始化或者使用get获取该成员变量是需要通过clone方法来确保类的不可变性。

- 如有必要，可以通过覆盖Object类的equals方法和hashCode方法。在equals方法中，根据对象的属性值来比较两个对象是否相等，并且保证用equals方法判断为相等的两个对象的hashCode方法的返回值也相等，这样可以保证这些对象能够正确的放入HashMap或HashSet等集合中。

    ```java
    import java.util.Date;
    public class ImmutableClass {
        private Date date;
        private ImmutableClass(Date d) {
            this.date = (Date) d.clone(); //解除引用关系
        }
        public void printState() {
            System.out.println(date);
        }
        public Date getDate() {
            return (Date) date.clone();
        }
    
        public static void main(String[] args) {
            Date d = new Date();
            ImmutableClass immutableClass = new ImmutableClass(d);
            immutableClass.printState();
            d.setTime(1111);
            immutableClass.printState();
        }
    }
    
    ```

### 1.2、常见不可变类：

- Java类库中，所有基本类型的包装类都是不可变类。eg：Float、Integer等
- String字符串。

### 1.3、优缺点

- 优点：不可变类具有使用简单、线程安全、节省内存的特点
- 缺点：会因为值的不同而产生新的对象

### 1.4、面试题

对于一些面感的数据（比如密码），为什么使用字符串数组存储比使用String更安全？

答：在Java语言中，String是不可变类，它被存储在字符串常量池中，从而实现了字符串的共享，减少了内存的开支。一个字符串被创建出来，这个字符串就被存储在常量池中，直到被垃圾收集器回收为止。因此，即使这个字符串不再被使用，仍然会在内存中存在一段时间。如果此时有权限访问memery dump（存储器转储）的程序可以访问这个字符串，从而把面感的数据暴露出去。如果使用字符数组，那么一旦程序不再使用这个数据，程序员就可以再把字符数组的内容设置为空，内存中就不存在了。

## 2、Java关键字

### 2.1、static关键字

- 为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。
- 实现某个方法或属性与类的关联在一起，而不是与类的对象。

### 2.2、final关键字

final关键字用于声明属性、方法和类。

- final属性：被final修饰的变量不可变。final引用变量不可变性，即它只能只想初始化时所指向的那个对象，而不关心对象内容的变化。
- final方法：被final修饰的方法不允许任何子类重写这个方法，但是子类可以使用这个方法。
- final参数：被final修饰的方法参数在方法内部不允许被修改。
- final类：被final修饰的类，不能被继承，所有方法都不能被重写。但是这不意味着final类的成员变量也是不可变的，想要成员变量不可改变，必须给成员变量增加final修饰。
- 引申：为什么匿名内部类只能使用成员变量或者被final修改的局部变量？
    - 因为匿名内部类的生存期可能比一般的局部变量更久。比如一个Runnable的实现体，有可能在数秒之后才被调用，而它的外部方法已经随着代码执行完毕而消亡了，之前定义在外部方法体内的变量随着方法体内存的回收也一起消失了。而被final修饰的局部变量在匿名内部类中有一个引用的副本，由于它本身不可被修改引用，所以可以在开发期认为final局部变量和内部类的引用副本是同一个引用。

### 2.3、transient

Java提供了对象序列化机制。当持久化一个对象时，可能并不想持久化所有的属性。对于这种情况，可以用transient修饰属性即可。

### 2.4、volatile

- 被volatile修饰的属性被多线程访问的时候，可以保持修改对所有线程可见。

- 相比synchronized，它仅用于修饰属性，且它只保持线程安全三要素中的可见性和有序性，并不能保证操作的原子性。
- volatile的实现是基于内存栅栏（Memory barrier）。
- 一个volatile字段在修改时，JVM会执行一个Write-Barrier操作，该操作将当前处理器缓存的数据写回系统内存，并且使其他CPU核心里引用可该地址的数据变成了脏数据。当读取时，JVM会多执行一个Read-Barrier指令，如果该数据已经变脏，那么从主存中重新获取数据。

## 3、Java多态

- 重载Overload：同一个类中有多个同名的方法，但这些方法有不同的参数，在程序编译时就确定调用哪一个方法，属于编译期间多态。
- 覆盖Override：子类覆盖父类的方法，同一个方法在父类和子类中有不同的实现。Java中父类的引用变量可以指向父类的实例变量，也可以指向子类的实例变量。接口类型变量同样也是。因此在程序运行期间才能确定具体实例对象，调用其对应的方法。这种通过动态绑定的方式实现多态，称为运行时多态。









